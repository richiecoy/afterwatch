{% extends "base.html" %}

{% block title %}Dashboard - Afterwatch{% endblock %}

{% block content %}
<div x-data="dashboard()" x-init="init()">
    <h1>Dashboard</h1>

    <!-- Stats Row -->
    <div class="stats-grid">
        <div class="stat-card">
            <div class="stat-value" x-text="episodes">0</div>
            <div class="stat-label">Episodes Processed</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" x-text="space">0 B</div>
            <div class="stat-label">Space Reclaimed</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" x-text="pendingCount">0</div>
            <div class="stat-label">Pending</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" x-text="orphanCount">0</div>
            <div class="stat-label">Orphaned</div>
        </div>
    </div>
    
    <!-- Status Row -->
    <div class="stats-grid status-row">
        <div class="stat-card">
            <div class="stat-label">Last Run</div>
            <div class="stat-value small" x-text="lastRunStatus">Never</div>
            <div class="stat-detail" x-text="lastRunTime"></div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Schedule</div>
            <div class="stat-value small" x-text="scheduleDesc">Disabled</div>
            <div class="stat-detail" x-text="nextRun ? 'Next: ' + nextRun : ''"></div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Delay</div>
            <div class="stat-value small" x-text="delayDays + ' days'">7 days</div>
            <div class="stat-detail">Before processing</div>
        </div>
        <div class="stat-card" :class="{ 'card-warning': testMode }">
            <div class="stat-label">Test Mode</div>
            <div class="stat-value small" :class="{ 'text-warning': testMode }" x-text="testMode ? 'ON' : 'OFF'">OFF</div>
            <button class="btn btn-small btn-toggle" @click="toggleTestMode()" x-text="testMode ? 'Disable' : 'Enable'"></button>
        </div>
    </div>
    
    <!-- Actions -->
    <section class="dashboard-actions">
        <h2>Actions</h2>
        <div class="action-buttons">
            <button class="btn btn-primary" @click="runNow()">Run Now</button>
            <button class="btn btn-secondary" @click="openPendingModal()" :disabled="pendingCount === 0">
                Process Pending (<span x-text="pendingCount">0</span>)
            </button>
        </div>
        <p class="warning-text" x-show="testMode">
            âš  Test mode is enabled. Processing will simulate actions without making changes.
        </p>
    </section>
    
    <!-- Pending Modal -->
    <div class="modal-overlay" x-show="showPendingModal" x-cloak @click.self="showPendingModal = false">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Process Pending Episodes</h2>
                <button class="modal-close" @click="showPendingModal = false">&times;</button>
            </div>
            <div class="modal-body">
                <template x-if="pendingEpisodes.length === 0">
                    <p>No pending episodes.</p>
                </template>
                <template x-if="pendingEpisodes.length > 0">
                    <div>
                        <label class="checkbox-label select-all">
                            <input type="checkbox" @change="toggleSelectAll($event)" :checked="allSelected">
                            <strong>Select All</strong>
                        </label>
                        <div class="pending-list">
                            <template x-for="ep in pendingEpisodes" :key="ep.id">
                                <label class="checkbox-label pending-item">
                                    <input type="checkbox" :value="ep.id" x-model="selectedPending">
                                    <span x-text="ep.series_name + ' S' + String(ep.season_number).padStart(2, '0') + 'E' + String(ep.episode_number).padStart(2, '0')"></span>
                                    <span class="pending-days" x-text="ep.days_remaining + ' days left'"></span>
                                </label>
                            </template>
                        </div>
                    </div>
                </template>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" @click="showPendingModal = false">Cancel</button>
                <button 
                    class="btn btn-primary" 
                    @click="processSelected()" 
                    :disabled="selectedPending.length === 0 || processing"
                    x-text="processing ? 'Processing...' : 'Process Selected (' + selectedPending.length + ')'"
                >
                </button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
function dashboard() {
    return {
        episodes: 0,
        space: '0 B',
        pendingCount: 0,
        orphanCount: 0,
        lastRunStatus: 'Never',
        lastRunTime: '',
        scheduleDesc: 'Disabled',
        nextRun: null,
        delayDays: 7,
        testMode: false,
        showPendingModal: false,
        pendingEpisodes: [],
        selectedPending: [],
        processing: false,
        
        get allSelected() {
            return this.pendingEpisodes.length > 0 && 
                   this.selectedPending.length === this.pendingEpisodes.length;
        },
        
        async init() {
            await this.loadStats();
            await this.loadCounts();
            await this.loadScheduleInfo();
            await this.loadLastRun();
        },
        
        async loadStats() {
            try {
                const response = await fetch('/api/stats');
                const data = await response.json();
                this.episodes = data.episodes_processed || 0;
                this.space = data.space_reclaimed || '0 B';
                this.testMode = data.test_mode || false;
            } catch (e) {
                console.error('Failed to load stats:', e);
            }
        },
        
        async loadCounts() {
            try {
                const response = await fetch('/api/counts');
                const data = await response.json();
                this.pendingCount = data.pending_count || 0;
                this.orphanCount = data.orphan_count || 0;
            } catch (e) {
                console.error('Failed to load counts:', e);
            }
        },
        
        async loadScheduleInfo() {
            try {
                const response = await fetch('/api/schedule-info');
                const data = await response.json();
                this.scheduleDesc = data.description || 'Disabled';
                this.nextRun = data.next_run;
            } catch (e) {
                console.error('Failed to load schedule info:', e);
            }
        },
        
        async loadLastRun() {
            try {
                const response = await fetch('/api/last-run');
                if (response.ok && response.status !== 204) {
                    const data = await response.json();
                    if (data) {
                        this.lastRunStatus = data.status;
                        this.lastRunTime = data.started_at;
                    }
                }
                
                const pendingResponse = await fetch('/api/pending');
                const pendingData = await pendingResponse.json();
                this.delayDays = pendingData.delay_days || 7;
            } catch (e) {
                console.error('Failed to load last run:', e);
            }
        },
        
        async runNow() {
            try {
                await fetch('/api/process', { method: 'POST' });
                window.location.href = '/logs/';
            } catch (e) {
                alert('Failed to start processing: ' + e.message);
            }
        },
        
        async toggleTestMode() {
            try {
                const response = await fetch('/api/toggle-test-mode', { method: 'POST' });
                const data = await response.json();
                this.testMode = data.test_mode;
            } catch (e) {
                alert('Failed to toggle test mode: ' + e.message);
            }
        },
        
        async openPendingModal() {
            await this.loadPendingEpisodes();
            this.showPendingModal = true;
        },
        
        async loadPendingEpisodes() {
            try {
                const response = await fetch('/api/pending');
                const data = await response.json();
                this.pendingEpisodes = data.pending;
                this.selectedPending = [];
            } catch (e) {
                console.error('Failed to load pending episodes:', e);
            }
        },
        
        toggleSelectAll(event) {
            if (event.target.checked) {
                this.selectedPending = this.pendingEpisodes.map(ep => ep.id);
            } else {
                this.selectedPending = [];
            }
        },
        
        async processSelected() {
            if (this.selectedPending.length === 0) return;
            
            this.processing = true;
            
            try {
                const response = await fetch('/api/process-pending', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ids: this.selectedPending })
                });
                const data = await response.json();
                
                if (data.success) {
                    alert(`Processed ${data.processed} episodes, reclaimed ${data.size_formatted}`);
                    this.showPendingModal = false;
                    await this.loadCounts();
                    await this.loadStats();
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (e) {
                alert('Failed to process: ' + e.message);
            } finally {
                this.processing = false;
            }
        }
    }
}
</script>
{% endblock %}
